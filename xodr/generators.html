<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>scenariogeneration.xodr.generators API documentation</title>
<meta name="description" content="This is a collection of ready to use functions, to generate standard road snipets, like:
- Simple straight road
- Spiral-Arc-Spiral type of turns
- â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenariogeneration.xodr.generators</code></h1>
</header>
<section id="section-intro">
<p>This is a collection of ready to use functions, to generate standard road snipets, like:
- Simple straight road
- Spiral-Arc-Spiral type of turns
- Simple roads with different geometries and lanes
- Simple junction roads
limited to 3/4-way crossings with 90degree turns (3-way can be 120 deg aswell)
- Creation of the junction based on the connecting roads and incomming/outgoing roads</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; This is a collection of ready to use functions, to generate standard road snipets, like:
    - Simple straight road
    - Spiral-Arc-Spiral type of turns
    - Simple roads with different geometries and lanes
    - Simple junction roads
        limited to 3/4-way crossings with 90degree turns (3-way can be 120 deg aswell)
    - Creation of the junction based on the connecting roads and incomming/outgoing roads
&#34;&#34;&#34;
import numpy as np

from .lane import Lane, RoadMark, LaneSection, Lanes
from .enumerations import RoadMarkType, MarkRule, ContactPoint, ElementType, ObjectType

from .geometry import Line, Arc, Spiral, EulerSpiral, PlanView
from .opendrive import Road, OpenDrive
from .links import Junction, Connection, _get_related_lanesection


STD_ROADMARK_SOLID = RoadMark(RoadMarkType.solid,0.2)
STD_ROADMARK_BROKEN = RoadMark(RoadMarkType.broken,0.2)
STD_START_CLOTH = 1/1000000000
def standard_lane(offset=3,rm = STD_ROADMARK_BROKEN):
    &#34;&#34;&#34; standard_lane creates a simple lane with an offset an a roadmark
        
        Parameters
        ----------
            offset (int): width of the lane
                default: 3

            rm (RoadMark): road mark used for the standard lane
                default:  RoadMark(STD_ROADMARK_BROKEN)
        Returns
        -------
            lane (Lane): the lane

    &#34;&#34;&#34;
    lc = Lane(a=offset)
    lc.add_roadmark(rm)
    return lc


def create_road(geometry,id,left_lanes = 1, right_lanes = 1,road_type=-1,center_road_mark = STD_ROADMARK_SOLID, lane_width=3):
    &#34;&#34;&#34; create_road creates a road with one lanesection with different number of lanes, lane marks will be of type broken, 
        except the outer lane, that will be solid. 

        Parameters
        ----------
            geometry (Line, Spiral, ParamPoly3, or Arc, or list with these): geometries to build the road

            id (int): id of the new road

            left_lanes (int): number of left lanes wanted
                Default: 1

            right_lanes (int): number of right lanes wanted
                Default: 1

            road_type (int): type of road, -1 normal road, otherwise connecting road

            center_road_mark (RoadMark): roadmark for the center line

            lane_width (float): the with of all lanes
    
        Returns
        -------
            road (Road): a straight road
    &#34;&#34;&#34;
    pv = PlanView()
    raw_length = 0
    if isinstance(geometry,list):
        for g in geometry:
            pv.add_geometry(g)
            raw_length += g.length
    else:
        pv.add_geometry(geometry)
        raw_length += geometry.length
    
    # create centerlane
    lc = Lane(a=0)
    lc.add_roadmark(center_road_mark)

    lsec = LaneSection(0,lc)
    # create left lanes
    for i in range(left_lanes):
        if i == left_lanes-1:
            leftlane = standard_lane(lane_width,STD_ROADMARK_SOLID) 
        else:
            leftlane = standard_lane(lane_width,STD_ROADMARK_BROKEN) 
        lsec.add_left_lane(leftlane)
    
    for i in range(right_lanes):
        if i == right_lanes-1:
            rightlane = standard_lane(lane_width,STD_ROADMARK_SOLID)
        else:
            rightlane = standard_lane(lane_width,STD_ROADMARK_BROKEN)
        lsec.add_right_lane(rightlane)
    lanes = Lanes()
    lanes.add_lanesection(lsec)
    
    road = Road(id,pv,lanes,road_type=road_type)
    
    return road

def create_straight_road(road_id, length=100,junction = -1, n_lanes=1, lane_offset=3):
    &#34;&#34;&#34; creates a standard straight road with two lanes

        Parameters
        ----------
            road_id (int): id of the road to create

            length (float): length of the road
                default: 100

            junction (int): if the road belongs to a junction or not
                default: -1
        Returns
        -------
            road (Road): a straight road
    &#34;&#34;&#34;
    # create geometry
    line1 = Line(length)

    # create planviews
    planview1 = PlanView()
    planview1.add_geometry(line1)

    # create lanesections
    lanesec1 = LaneSection(0,standard_lane())
    for i in range(1, n_lanes+1, 1):
        lanesec1.add_right_lane(standard_lane(lane_offset))
        lanesec1.add_left_lane(standard_lane(lane_offset))

    # create lanes
    lanes1 = Lanes()
    lanes1.add_lanesection(lanesec1)

    # finally create the roads 
    return Road(road_id,planview1,lanes1,road_type=junction)


def create_cloth_arc_cloth(arc_curv, arc_angle, cloth_angle, r_id, junction = 1,cloth_start = STD_START_CLOTH, n_lanes=1, lane_offset=3):
    &#34;&#34;&#34; creates a curved Road  with a Spiral - Arc - Spiral, and two lanes

        Parameters
        ----------
            arc_curv (float): curvature of the arc (and max clothoid of clothoids)

            arc_angle (float): how much of the curv should be the arc

            cloth_angle (float): how much of the curv should be the clothoid (will be doubled since there are two clothoids)
            
            r_id (int): the id of the road

            junction (int): if the Road belongs to a junction
                default: 1

            cloth_start (float): staring curvature of clothoids

        Returns
        -------
            road (Road): a road built up of a Spiral-Arc-Spiral
    &#34;&#34;&#34;
    
    pv = PlanView()
    # adjust sign if angle is negative
    if cloth_angle &lt; 0 and  arc_curv &gt; 0:

        cloth_angle = -cloth_angle
        arc_curv = -arc_curv
        cloth_start = -cloth_start
        arc_angle = -arc_angle 
    
    # create geometries
    spiral1 = Spiral(cloth_start, arc_curv, angle=cloth_angle)
    arc = Arc(arc_curv, angle=arc_angle )
    spiral2 = Spiral(arc_curv, cloth_start, angle=cloth_angle)

    pv.add_geometry(spiral1)
    pv.add_geometry(arc)
    pv.add_geometry(spiral2)

    # create lanes
    lsec = LaneSection(0,standard_lane())
    for i in range(1, n_lanes+1, 1):
        lsec.add_right_lane(standard_lane(lane_offset))
        lsec.add_left_lane(standard_lane(lane_offset))
    lanes = Lanes()
    lanes.add_lanesection(lsec)

    # create road
    return Road(r_id,pv,lanes,road_type=junction)

def get_lanes_offset(road1, road2, contactpoint):
    &#34;&#34;&#34; returns number of lanes (hp #left lanes = # right lanes) and their offset (hp offset is constant)


        Parameters
        ----------
            road1 (Road): first road 

            road2 (Road): second road 

        Returns
        -------
            n_lanes (int): 

            lane_offset (int):
    &#34;&#34;&#34;
    #now we always look at lanesection[0] to take the number of lanes 
    #TO DO - understand if the roads are connect through end or start and then take the relative lane section 
    if contactpoint == ContactPoint.end: 
        n_lanesection = 0 
    else:
        n_lanesection = -1
    if len(road1.lanes.lanesections[n_lanesection].leftlanes) == len(road2.lanes.lanesections[0].leftlanes) and len(road1.lanes.lanesections[n_lanesection].rightlanes) == len(road2.lanes.lanesections[0].rightlanes):
        n_lanes = len(road1.lanes.lanesections[n_lanesection].leftlanes) 
        lane_offset = road1.lanes.lanesections[n_lanesection].leftlanes[0].a     
    else:
        raise NotSameAmountOfLanesError(&#39;Incoming road &#39;,road1.id, &#39; and outcoming road &#39;, road2.id, &#39;do not have the same number of left lanes.&#39;)
        
    return n_lanes, lane_offset 




def create_junction_roads_standalone(angles,r,junction=1,spiral_part = 1/3, arc_part = 1/3,startnum=100,n_lanes=1,lane_width=3):
    &#34;&#34;&#34; creates all needed roads for some simple junctions, the curved parts of the junction are created as a spiral-arc-spiral combo 
        - 3way crossings (either a T junction, or 120 deg junction)
        - 4way crossing (all 90 degree turns)
        NOTE: this will not generate any links or add any successor/predecessors to the roads, and has to be added manually,
        if you have the connecting roads please use create_junction_roads

        Parameters
        ----------
       
            angles (list of float): the angles from where the roads should be coming in (see description for what is supported), 
                                    to be defined in mathimatically positive order, beginning with the first incoming road

            r (float): the radius of the arcs in the junction (will determine the size of the junction)
            
            junction (int): the id of the junction
                default: 1

            spiral_part (float): the part of the curve that should be spirals (two of these) spiral_part*2 + arcpart = angle of the turn
                default: (1/3)

            arc_part (float): the part of the curve that should be an arc:  spiral_part*2 + arcpart = angle of the turn
                default: (1/3)

            startnum (int): start number of the roads in the junctions (will increase with 1 for each road)
            
            n_lanes (int): the number of lanes in the junction

            lane_width (double): the lane width of the lanes in the junction
        Returns
        -------
            junction_roads (list of Road): a list of all roads in a junction without connections added

    &#34;&#34;&#34;
    angle = np.pi/2
    angle_cloth = angle*spiral_part 
    spiral_length = 2*abs(angle_cloth*r)

    spiral = EulerSpiral.createFromLengthAndCurvature(spiral_length, STD_START_CLOTH, 1/r)
    (X, Y, _) = spiral.calc(spiral_length, 0, 0, STD_START_CLOTH, 0)

    X0 = X-r*np.sin(angle_cloth)
    Y0 = Y-r*(1-np.cos(angle_cloth))
    linelength = 2*(X0 + r + Y0)

    junction_roads = []
    
    for i in range(len(angles)-1):
        
        for j in range(1+i,len(angles)):
            # check angle needed for junction
            an = np.sign(angles[j]-angles[i]-np.pi)
            an1 = angles[j]-angles[i] -np.pi
            angle_arc = an1*arc_part

            angle_cloth = an1*spiral_part

            #adjust angle if multiple of pi
            if an1 &gt; np.pi: 
                an1 = -(2*np.pi - an1)

            # create road, either straight or curved
            if an == 0:
                tmp_junc = create_straight_road(startnum,length= linelength,junction=junction, n_lanes=n_lanes, lane_offset=lane_width)
            else: 
                tmp_junc = create_cloth_arc_cloth(  1/r , angle_arc , angle_cloth , startnum , junction, n_lanes=n_lanes, lane_offset=lane_width )

            # add predecessor and successor
            startnum += 1
            junction_roads.append(tmp_junc)

    return junction_roads
    
def create_junction_roads(roads,angles,r,junction=1,spiral_part = 1/3, arc_part = 1/3,startnum=100):
    &#34;&#34;&#34; creates all needed roads for some simple junctions, the curved parts of the junction are created as a spiral-arc-spiral combo
        Supported junctions:
        - 3way crossings (either a T junction, or 120 deg junction)
        - 4way crossing (all 90 degree turns)

        Parameters
        ----------
            roads (list of Road): all roads that should go into the junction

            angles (list of float): the angles from where the roads should be coming in (see description for what is supported), 
                                    to be defined in mathimatically positive order, beginning with the first incoming road

            r (float): the radius of the arcs in the junction (will determine the size of the junction)
            
            junction (int): the id of the junction
                default: 1

            spiral_part (float): the part of the curve that should be spirals (two of these) spiral_part*2 + arcpart = angle of the turn
                default: (1/3)

            arc_part (float): the part of the curve that should be an arc:  spiral_part*2 + arcpart = angle of the turn
                default: (1/3)

            startnum (int): start number of the roads in the junctions (will increase with 1 for each road)

        Returns
        -------
            junction_roads (list of Road): a list of all roads needed for all traffic connecting the roads
    &#34;&#34;&#34;

    # if a straight line is used, calculate the length of it. Some Spiral Magic going on...
    # http://www.jerrymahun.com/index.php/home/open-access/viii-curves/76-chapter-e-spirals?showall=1

    angle = np.pi/2
    angle_cloth = angle*spiral_part 
    spiral_length = 2*abs(angle_cloth*r)

    spiral = EulerSpiral.createFromLengthAndCurvature(spiral_length, STD_START_CLOTH, 1/r)
    (X, Y, _) = spiral.calc(spiral_length, 0, 0, STD_START_CLOTH, 0)

    X0 = X-r*np.sin(angle_cloth)
    Y0 = Y-r*(1-np.cos(angle_cloth))
    linelength = 2*(X0 + r + Y0)

    junction_roads = []

    # loop over the roads to get all possible combinations of connecting roads
    for i in range(len(roads)-1):
        # for now the first road is place as base, 
        if i == 0:
            cp = ContactPoint.end
            roads[i].add_successor(ElementType.junction,junction)
        else:
            cp = ContactPoint.start
            roads[i].add_predecessor(ElementType.junction,junction)
        
        for j in range(1+i,len(roads)):
            # check angle needed for junction
            an = np.sign(angles[j]-angles[i]-np.pi)
            an1 = angles[j]-angles[i] -np.pi
            angle_arc = an1*arc_part

            angle_cloth = an1*spiral_part

            #adjust angle if multiple of pi
            if an1 &gt; np.pi: 
                an1 = -(2*np.pi - an1)

            # create road, either straight or curved
            n_lanes, lanes_offset = get_lanes_offset(roads[i], roads[j], cp )
            if an == 0:
                tmp_junc = create_straight_road(startnum,length= linelength,junction=junction, n_lanes=n_lanes, lane_offset=lanes_offset)
            else: 
                tmp_junc = create_cloth_arc_cloth(  1/r , angle_arc , angle_cloth , startnum , junction, n_lanes=n_lanes, lane_offset=lanes_offset )

            # add predecessor and successor
            tmp_junc.add_predecessor(ElementType.road,roads[i].id,cp)
            tmp_junc.add_successor(ElementType.road,roads[j].id,ContactPoint.start)
            startnum += 1
            junction_roads.append(tmp_junc)

    # add junction to the last road aswell since it&#39;s not part of the loop
    roads[-1].add_predecessor(ElementType.junction,junction)

    return junction_roads

def _create_junction_links(connection, nlanes,r_or_l,sign,from_offset=0,to_offset=0):
    &#34;&#34;&#34; helper function to create junction links

        Parameters
        ----------
            connection (Connection): the connection to fill

            nlanes (int): number of lanes 

            r_or_l (1 or -1): if the lane should start from -1 or 1

            sign (1 or -1): if the sign should change 

            from_offset (int): if there is an offset in the beginning 
                Default: 0

            to_offset (int): if there is an offset in the end of the road 
                Default: 0
    &#34;&#34;&#34;
    for i in range(1, nlanes+1, 1):
        connection.add_lanelink( r_or_l*i+from_offset, r_or_l*sign*i+to_offset)


def create_junction(junction_roads, id, roads, name=&#39;my junction&#39;):
    &#34;&#34;&#34; create_junction creates the junction struct for a set of roads


        Parameters
        ----------
            junction_roads (list of Road): all connecting roads in the junction

            id (int): the id of the junction
            
            roads (list of Road): all incomming roads to the junction
            
            name(str): name of the junction
            default: &#39;my junction&#39;

        Returns
        -------
            junction (Junction): the junction struct ready to use

    &#34;&#34;&#34;



    junc = Junction(name,id)
    
    for jr in junction_roads:
        # handle succesor lanes
        conne1 = Connection(jr.successor.element_id,jr.id,ContactPoint.end) 
        _, sign, _ =  _get_related_lanesection(jr,get_road_by_id(roads,jr.successor.element_id) ) 

        _create_junction_links(conne1,len(jr.lanes.lanesections[-1].rightlanes),-1,sign,to_offset=jr.lane_offset_suc)
        _create_junction_links(conne1,len(jr.lanes.lanesections[-1].leftlanes),1,sign,to_offset=jr.lane_offset_suc)
        junc.add_connection(conne1)

        # handle predecessor lanes
        conne2 = Connection(jr.predecessor.element_id,jr.id,ContactPoint.start)
        _, sign, _ =  _get_related_lanesection( jr,get_road_by_id(roads,jr.predecessor.element_id)) 
        _create_junction_links(conne2,len(jr.lanes.lanesections[0].rightlanes),-1,sign,from_offset=jr.lane_offset_pred)
        _create_junction_links(conne2,len(jr.lanes.lanesections[0].leftlanes),1,sign,from_offset=jr.lane_offset_pred)
        junc.add_connection(conne2)
    return junc

def get_road_by_id(roads,id):
    &#34;&#34;&#34; get_road_by_id returns a road based on the road id

        Parameters
        ----------
            roads (list of Roads): a list of roads to seach through

            id (int): the id of the road wanted

        Returns
        -------
            Road
    &#34;&#34;&#34;
    for r in roads:
        if r.id == id:
            return r</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="scenariogeneration.xodr.generators.create_cloth_arc_cloth"><code class="name flex">
<span>def <span class="ident">create_cloth_arc_cloth</span></span>(<span>arc_curv, arc_angle, cloth_angle, r_id, junction=1, cloth_start=1e-09, n_lanes=1, lane_offset=3)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a curved Road
with a Spiral - Arc - Spiral, and two lanes</p>
<h2 id="parameters">Parameters</h2>
<pre><code>arc_curv (float): curvature of the arc (and max clothoid of clothoids)

arc_angle (float): how much of the curv should be the arc

cloth_angle (float): how much of the curv should be the clothoid (will be doubled since there are two clothoids)

r_id (int): the id of the road

junction (int): if the Road belongs to a junction
    default: 1

cloth_start (float): staring curvature of clothoids
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>road (Road): a road built up of a Spiral-Arc-Spiral
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_cloth_arc_cloth(arc_curv, arc_angle, cloth_angle, r_id, junction = 1,cloth_start = STD_START_CLOTH, n_lanes=1, lane_offset=3):
    &#34;&#34;&#34; creates a curved Road  with a Spiral - Arc - Spiral, and two lanes

        Parameters
        ----------
            arc_curv (float): curvature of the arc (and max clothoid of clothoids)

            arc_angle (float): how much of the curv should be the arc

            cloth_angle (float): how much of the curv should be the clothoid (will be doubled since there are two clothoids)
            
            r_id (int): the id of the road

            junction (int): if the Road belongs to a junction
                default: 1

            cloth_start (float): staring curvature of clothoids

        Returns
        -------
            road (Road): a road built up of a Spiral-Arc-Spiral
    &#34;&#34;&#34;
    
    pv = PlanView()
    # adjust sign if angle is negative
    if cloth_angle &lt; 0 and  arc_curv &gt; 0:

        cloth_angle = -cloth_angle
        arc_curv = -arc_curv
        cloth_start = -cloth_start
        arc_angle = -arc_angle 
    
    # create geometries
    spiral1 = Spiral(cloth_start, arc_curv, angle=cloth_angle)
    arc = Arc(arc_curv, angle=arc_angle )
    spiral2 = Spiral(arc_curv, cloth_start, angle=cloth_angle)

    pv.add_geometry(spiral1)
    pv.add_geometry(arc)
    pv.add_geometry(spiral2)

    # create lanes
    lsec = LaneSection(0,standard_lane())
    for i in range(1, n_lanes+1, 1):
        lsec.add_right_lane(standard_lane(lane_offset))
        lsec.add_left_lane(standard_lane(lane_offset))
    lanes = Lanes()
    lanes.add_lanesection(lsec)

    # create road
    return Road(r_id,pv,lanes,road_type=junction)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.generators.create_junction"><code class="name flex">
<span>def <span class="ident">create_junction</span></span>(<span>junction_roads, id, roads, name='my junction')</span>
</code></dt>
<dd>
<div class="desc"><p>create_junction creates the junction struct for a set of roads</p>
<h2 id="parameters">Parameters</h2>
<pre><code>junction_roads (list of Road): all connecting roads in the junction

id (int): the id of the junction

roads (list of Road): all incomming roads to the junction

name(str): name of the junction
default: 'my junction'
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>junction (Junction): the junction struct ready to use
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_junction(junction_roads, id, roads, name=&#39;my junction&#39;):
    &#34;&#34;&#34; create_junction creates the junction struct for a set of roads


        Parameters
        ----------
            junction_roads (list of Road): all connecting roads in the junction

            id (int): the id of the junction
            
            roads (list of Road): all incomming roads to the junction
            
            name(str): name of the junction
            default: &#39;my junction&#39;

        Returns
        -------
            junction (Junction): the junction struct ready to use

    &#34;&#34;&#34;



    junc = Junction(name,id)
    
    for jr in junction_roads:
        # handle succesor lanes
        conne1 = Connection(jr.successor.element_id,jr.id,ContactPoint.end) 
        _, sign, _ =  _get_related_lanesection(jr,get_road_by_id(roads,jr.successor.element_id) ) 

        _create_junction_links(conne1,len(jr.lanes.lanesections[-1].rightlanes),-1,sign,to_offset=jr.lane_offset_suc)
        _create_junction_links(conne1,len(jr.lanes.lanesections[-1].leftlanes),1,sign,to_offset=jr.lane_offset_suc)
        junc.add_connection(conne1)

        # handle predecessor lanes
        conne2 = Connection(jr.predecessor.element_id,jr.id,ContactPoint.start)
        _, sign, _ =  _get_related_lanesection( jr,get_road_by_id(roads,jr.predecessor.element_id)) 
        _create_junction_links(conne2,len(jr.lanes.lanesections[0].rightlanes),-1,sign,from_offset=jr.lane_offset_pred)
        _create_junction_links(conne2,len(jr.lanes.lanesections[0].leftlanes),1,sign,from_offset=jr.lane_offset_pred)
        junc.add_connection(conne2)
    return junc</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.generators.create_junction_roads"><code class="name flex">
<span>def <span class="ident">create_junction_roads</span></span>(<span>roads, angles, r, junction=1, spiral_part=0.3333333333333333, arc_part=0.3333333333333333, startnum=100)</span>
</code></dt>
<dd>
<div class="desc"><p>creates all needed roads for some simple junctions, the curved parts of the junction are created as a spiral-arc-spiral combo
Supported junctions:
- 3way crossings (either a T junction, or 120 deg junction)
- 4way crossing (all 90 degree turns)</p>
<h2 id="parameters">Parameters</h2>
<pre><code>roads (list of Road): all roads that should go into the junction

angles (list of float): the angles from where the roads should be coming in (see description for what is supported), 
                        to be defined in mathimatically positive order, beginning with the first incoming road

r (float): the radius of the arcs in the junction (will determine the size of the junction)

junction (int): the id of the junction
    default: 1

spiral_part (float): the part of the curve that should be spirals (two of these) spiral_part*2 + arcpart = angle of the turn
    default: (1/3)

arc_part (float): the part of the curve that should be an arc:  spiral_part*2 + arcpart = angle of the turn
    default: (1/3)

startnum (int): start number of the roads in the junctions (will increase with 1 for each road)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>junction_roads (list of Road): a list of all roads needed for all traffic connecting the roads
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_junction_roads(roads,angles,r,junction=1,spiral_part = 1/3, arc_part = 1/3,startnum=100):
    &#34;&#34;&#34; creates all needed roads for some simple junctions, the curved parts of the junction are created as a spiral-arc-spiral combo
        Supported junctions:
        - 3way crossings (either a T junction, or 120 deg junction)
        - 4way crossing (all 90 degree turns)

        Parameters
        ----------
            roads (list of Road): all roads that should go into the junction

            angles (list of float): the angles from where the roads should be coming in (see description for what is supported), 
                                    to be defined in mathimatically positive order, beginning with the first incoming road

            r (float): the radius of the arcs in the junction (will determine the size of the junction)
            
            junction (int): the id of the junction
                default: 1

            spiral_part (float): the part of the curve that should be spirals (two of these) spiral_part*2 + arcpart = angle of the turn
                default: (1/3)

            arc_part (float): the part of the curve that should be an arc:  spiral_part*2 + arcpart = angle of the turn
                default: (1/3)

            startnum (int): start number of the roads in the junctions (will increase with 1 for each road)

        Returns
        -------
            junction_roads (list of Road): a list of all roads needed for all traffic connecting the roads
    &#34;&#34;&#34;

    # if a straight line is used, calculate the length of it. Some Spiral Magic going on...
    # http://www.jerrymahun.com/index.php/home/open-access/viii-curves/76-chapter-e-spirals?showall=1

    angle = np.pi/2
    angle_cloth = angle*spiral_part 
    spiral_length = 2*abs(angle_cloth*r)

    spiral = EulerSpiral.createFromLengthAndCurvature(spiral_length, STD_START_CLOTH, 1/r)
    (X, Y, _) = spiral.calc(spiral_length, 0, 0, STD_START_CLOTH, 0)

    X0 = X-r*np.sin(angle_cloth)
    Y0 = Y-r*(1-np.cos(angle_cloth))
    linelength = 2*(X0 + r + Y0)

    junction_roads = []

    # loop over the roads to get all possible combinations of connecting roads
    for i in range(len(roads)-1):
        # for now the first road is place as base, 
        if i == 0:
            cp = ContactPoint.end
            roads[i].add_successor(ElementType.junction,junction)
        else:
            cp = ContactPoint.start
            roads[i].add_predecessor(ElementType.junction,junction)
        
        for j in range(1+i,len(roads)):
            # check angle needed for junction
            an = np.sign(angles[j]-angles[i]-np.pi)
            an1 = angles[j]-angles[i] -np.pi
            angle_arc = an1*arc_part

            angle_cloth = an1*spiral_part

            #adjust angle if multiple of pi
            if an1 &gt; np.pi: 
                an1 = -(2*np.pi - an1)

            # create road, either straight or curved
            n_lanes, lanes_offset = get_lanes_offset(roads[i], roads[j], cp )
            if an == 0:
                tmp_junc = create_straight_road(startnum,length= linelength,junction=junction, n_lanes=n_lanes, lane_offset=lanes_offset)
            else: 
                tmp_junc = create_cloth_arc_cloth(  1/r , angle_arc , angle_cloth , startnum , junction, n_lanes=n_lanes, lane_offset=lanes_offset )

            # add predecessor and successor
            tmp_junc.add_predecessor(ElementType.road,roads[i].id,cp)
            tmp_junc.add_successor(ElementType.road,roads[j].id,ContactPoint.start)
            startnum += 1
            junction_roads.append(tmp_junc)

    # add junction to the last road aswell since it&#39;s not part of the loop
    roads[-1].add_predecessor(ElementType.junction,junction)

    return junction_roads</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.generators.create_junction_roads_standalone"><code class="name flex">
<span>def <span class="ident">create_junction_roads_standalone</span></span>(<span>angles, r, junction=1, spiral_part=0.3333333333333333, arc_part=0.3333333333333333, startnum=100, n_lanes=1, lane_width=3)</span>
</code></dt>
<dd>
<div class="desc"><p>creates all needed roads for some simple junctions, the curved parts of the junction are created as a spiral-arc-spiral combo
- 3way crossings (either a T junction, or 120 deg junction)
- 4way crossing (all 90 degree turns)
NOTE: this will not generate any links or add any successor/predecessors to the roads, and has to be added manually,
if you have the connecting roads please use create_junction_roads</p>
<h2 id="parameters">Parameters</h2>
<pre><code>angles (list of float): the angles from where the roads should be coming in (see description for what is supported), 
                        to be defined in mathimatically positive order, beginning with the first incoming road

r (float): the radius of the arcs in the junction (will determine the size of the junction)

junction (int): the id of the junction
    default: 1

spiral_part (float): the part of the curve that should be spirals (two of these) spiral_part*2 + arcpart = angle of the turn
    default: (1/3)

arc_part (float): the part of the curve that should be an arc:  spiral_part*2 + arcpart = angle of the turn
    default: (1/3)

startnum (int): start number of the roads in the junctions (will increase with 1 for each road)

n_lanes (int): the number of lanes in the junction

lane_width (double): the lane width of the lanes in the junction
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>junction_roads (list of Road): a list of all roads in a junction without connections added
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_junction_roads_standalone(angles,r,junction=1,spiral_part = 1/3, arc_part = 1/3,startnum=100,n_lanes=1,lane_width=3):
    &#34;&#34;&#34; creates all needed roads for some simple junctions, the curved parts of the junction are created as a spiral-arc-spiral combo 
        - 3way crossings (either a T junction, or 120 deg junction)
        - 4way crossing (all 90 degree turns)
        NOTE: this will not generate any links or add any successor/predecessors to the roads, and has to be added manually,
        if you have the connecting roads please use create_junction_roads

        Parameters
        ----------
       
            angles (list of float): the angles from where the roads should be coming in (see description for what is supported), 
                                    to be defined in mathimatically positive order, beginning with the first incoming road

            r (float): the radius of the arcs in the junction (will determine the size of the junction)
            
            junction (int): the id of the junction
                default: 1

            spiral_part (float): the part of the curve that should be spirals (two of these) spiral_part*2 + arcpart = angle of the turn
                default: (1/3)

            arc_part (float): the part of the curve that should be an arc:  spiral_part*2 + arcpart = angle of the turn
                default: (1/3)

            startnum (int): start number of the roads in the junctions (will increase with 1 for each road)
            
            n_lanes (int): the number of lanes in the junction

            lane_width (double): the lane width of the lanes in the junction
        Returns
        -------
            junction_roads (list of Road): a list of all roads in a junction without connections added

    &#34;&#34;&#34;
    angle = np.pi/2
    angle_cloth = angle*spiral_part 
    spiral_length = 2*abs(angle_cloth*r)

    spiral = EulerSpiral.createFromLengthAndCurvature(spiral_length, STD_START_CLOTH, 1/r)
    (X, Y, _) = spiral.calc(spiral_length, 0, 0, STD_START_CLOTH, 0)

    X0 = X-r*np.sin(angle_cloth)
    Y0 = Y-r*(1-np.cos(angle_cloth))
    linelength = 2*(X0 + r + Y0)

    junction_roads = []
    
    for i in range(len(angles)-1):
        
        for j in range(1+i,len(angles)):
            # check angle needed for junction
            an = np.sign(angles[j]-angles[i]-np.pi)
            an1 = angles[j]-angles[i] -np.pi
            angle_arc = an1*arc_part

            angle_cloth = an1*spiral_part

            #adjust angle if multiple of pi
            if an1 &gt; np.pi: 
                an1 = -(2*np.pi - an1)

            # create road, either straight or curved
            if an == 0:
                tmp_junc = create_straight_road(startnum,length= linelength,junction=junction, n_lanes=n_lanes, lane_offset=lane_width)
            else: 
                tmp_junc = create_cloth_arc_cloth(  1/r , angle_arc , angle_cloth , startnum , junction, n_lanes=n_lanes, lane_offset=lane_width )

            # add predecessor and successor
            startnum += 1
            junction_roads.append(tmp_junc)

    return junction_roads</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.generators.create_road"><code class="name flex">
<span>def <span class="ident">create_road</span></span>(<span>geometry, id, left_lanes=1, right_lanes=1, road_type=-1, center_road_mark=&lt;scenariogeneration.xodr.lane.RoadMark object&gt;, lane_width=3)</span>
</code></dt>
<dd>
<div class="desc"><p>create_road creates a road with one lanesection with different number of lanes, lane marks will be of type broken,
except the outer lane, that will be solid. </p>
<h2 id="parameters">Parameters</h2>
<pre><code>geometry (Line, Spiral, ParamPoly3, or Arc, or list with these): geometries to build the road

id (int): id of the new road

left_lanes (int): number of left lanes wanted
    Default: 1

right_lanes (int): number of right lanes wanted
    Default: 1

road_type (int): type of road, -1 normal road, otherwise connecting road

center_road_mark (RoadMark): roadmark for the center line

lane_width (float): the with of all lanes
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>road (Road): a straight road
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_road(geometry,id,left_lanes = 1, right_lanes = 1,road_type=-1,center_road_mark = STD_ROADMARK_SOLID, lane_width=3):
    &#34;&#34;&#34; create_road creates a road with one lanesection with different number of lanes, lane marks will be of type broken, 
        except the outer lane, that will be solid. 

        Parameters
        ----------
            geometry (Line, Spiral, ParamPoly3, or Arc, or list with these): geometries to build the road

            id (int): id of the new road

            left_lanes (int): number of left lanes wanted
                Default: 1

            right_lanes (int): number of right lanes wanted
                Default: 1

            road_type (int): type of road, -1 normal road, otherwise connecting road

            center_road_mark (RoadMark): roadmark for the center line

            lane_width (float): the with of all lanes
    
        Returns
        -------
            road (Road): a straight road
    &#34;&#34;&#34;
    pv = PlanView()
    raw_length = 0
    if isinstance(geometry,list):
        for g in geometry:
            pv.add_geometry(g)
            raw_length += g.length
    else:
        pv.add_geometry(geometry)
        raw_length += geometry.length
    
    # create centerlane
    lc = Lane(a=0)
    lc.add_roadmark(center_road_mark)

    lsec = LaneSection(0,lc)
    # create left lanes
    for i in range(left_lanes):
        if i == left_lanes-1:
            leftlane = standard_lane(lane_width,STD_ROADMARK_SOLID) 
        else:
            leftlane = standard_lane(lane_width,STD_ROADMARK_BROKEN) 
        lsec.add_left_lane(leftlane)
    
    for i in range(right_lanes):
        if i == right_lanes-1:
            rightlane = standard_lane(lane_width,STD_ROADMARK_SOLID)
        else:
            rightlane = standard_lane(lane_width,STD_ROADMARK_BROKEN)
        lsec.add_right_lane(rightlane)
    lanes = Lanes()
    lanes.add_lanesection(lsec)
    
    road = Road(id,pv,lanes,road_type=road_type)
    
    return road</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.generators.create_straight_road"><code class="name flex">
<span>def <span class="ident">create_straight_road</span></span>(<span>road_id, length=100, junction=-1, n_lanes=1, lane_offset=3)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a standard straight road with two lanes</p>
<h2 id="parameters">Parameters</h2>
<pre><code>road_id (int): id of the road to create

length (float): length of the road
    default: 100

junction (int): if the road belongs to a junction or not
    default: -1
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>road (Road): a straight road
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_straight_road(road_id, length=100,junction = -1, n_lanes=1, lane_offset=3):
    &#34;&#34;&#34; creates a standard straight road with two lanes

        Parameters
        ----------
            road_id (int): id of the road to create

            length (float): length of the road
                default: 100

            junction (int): if the road belongs to a junction or not
                default: -1
        Returns
        -------
            road (Road): a straight road
    &#34;&#34;&#34;
    # create geometry
    line1 = Line(length)

    # create planviews
    planview1 = PlanView()
    planview1.add_geometry(line1)

    # create lanesections
    lanesec1 = LaneSection(0,standard_lane())
    for i in range(1, n_lanes+1, 1):
        lanesec1.add_right_lane(standard_lane(lane_offset))
        lanesec1.add_left_lane(standard_lane(lane_offset))

    # create lanes
    lanes1 = Lanes()
    lanes1.add_lanesection(lanesec1)

    # finally create the roads 
    return Road(road_id,planview1,lanes1,road_type=junction)</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.generators.get_lanes_offset"><code class="name flex">
<span>def <span class="ident">get_lanes_offset</span></span>(<span>road1, road2, contactpoint)</span>
</code></dt>
<dd>
<div class="desc"><p>returns number of lanes (hp #left lanes = # right lanes) and their offset (hp offset is constant)</p>
<h2 id="parameters">Parameters</h2>
<pre><code>road1 (Road): first road

road2 (Road): second road
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>n_lanes (int):

lane_offset (int):
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_lanes_offset(road1, road2, contactpoint):
    &#34;&#34;&#34; returns number of lanes (hp #left lanes = # right lanes) and their offset (hp offset is constant)


        Parameters
        ----------
            road1 (Road): first road 

            road2 (Road): second road 

        Returns
        -------
            n_lanes (int): 

            lane_offset (int):
    &#34;&#34;&#34;
    #now we always look at lanesection[0] to take the number of lanes 
    #TO DO - understand if the roads are connect through end or start and then take the relative lane section 
    if contactpoint == ContactPoint.end: 
        n_lanesection = 0 
    else:
        n_lanesection = -1
    if len(road1.lanes.lanesections[n_lanesection].leftlanes) == len(road2.lanes.lanesections[0].leftlanes) and len(road1.lanes.lanesections[n_lanesection].rightlanes) == len(road2.lanes.lanesections[0].rightlanes):
        n_lanes = len(road1.lanes.lanesections[n_lanesection].leftlanes) 
        lane_offset = road1.lanes.lanesections[n_lanesection].leftlanes[0].a     
    else:
        raise NotSameAmountOfLanesError(&#39;Incoming road &#39;,road1.id, &#39; and outcoming road &#39;, road2.id, &#39;do not have the same number of left lanes.&#39;)
        
    return n_lanes, lane_offset </code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.generators.get_road_by_id"><code class="name flex">
<span>def <span class="ident">get_road_by_id</span></span>(<span>roads, id)</span>
</code></dt>
<dd>
<div class="desc"><p>get_road_by_id returns a road based on the road id</p>
<h2 id="parameters">Parameters</h2>
<pre><code>roads (list of Roads): a list of roads to seach through

id (int): the id of the road wanted
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>Road
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_road_by_id(roads,id):
    &#34;&#34;&#34; get_road_by_id returns a road based on the road id

        Parameters
        ----------
            roads (list of Roads): a list of roads to seach through

            id (int): the id of the road wanted

        Returns
        -------
            Road
    &#34;&#34;&#34;
    for r in roads:
        if r.id == id:
            return r</code></pre>
</details>
</dd>
<dt id="scenariogeneration.xodr.generators.standard_lane"><code class="name flex">
<span>def <span class="ident">standard_lane</span></span>(<span>offset=3, rm=&lt;scenariogeneration.xodr.lane.RoadMark object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>standard_lane creates a simple lane with an offset an a roadmark</p>
<h2 id="parameters">Parameters</h2>
<pre><code>offset (int): width of the lane
    default: 3

rm (RoadMark): road mark used for the standard lane
    default:  RoadMark(STD_ROADMARK_BROKEN)
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>lane (Lane): the lane
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def standard_lane(offset=3,rm = STD_ROADMARK_BROKEN):
    &#34;&#34;&#34; standard_lane creates a simple lane with an offset an a roadmark
        
        Parameters
        ----------
            offset (int): width of the lane
                default: 3

            rm (RoadMark): road mark used for the standard lane
                default:  RoadMark(STD_ROADMARK_BROKEN)
        Returns
        -------
            lane (Lane): the lane

    &#34;&#34;&#34;
    lc = Lane(a=offset)
    lc.add_roadmark(rm)
    return lc</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenariogeneration.xodr" href="index.html">scenariogeneration.xodr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="scenariogeneration.xodr.generators.create_cloth_arc_cloth" href="#scenariogeneration.xodr.generators.create_cloth_arc_cloth">create_cloth_arc_cloth</a></code></li>
<li><code><a title="scenariogeneration.xodr.generators.create_junction" href="#scenariogeneration.xodr.generators.create_junction">create_junction</a></code></li>
<li><code><a title="scenariogeneration.xodr.generators.create_junction_roads" href="#scenariogeneration.xodr.generators.create_junction_roads">create_junction_roads</a></code></li>
<li><code><a title="scenariogeneration.xodr.generators.create_junction_roads_standalone" href="#scenariogeneration.xodr.generators.create_junction_roads_standalone">create_junction_roads_standalone</a></code></li>
<li><code><a title="scenariogeneration.xodr.generators.create_road" href="#scenariogeneration.xodr.generators.create_road">create_road</a></code></li>
<li><code><a title="scenariogeneration.xodr.generators.create_straight_road" href="#scenariogeneration.xodr.generators.create_straight_road">create_straight_road</a></code></li>
<li><code><a title="scenariogeneration.xodr.generators.get_lanes_offset" href="#scenariogeneration.xodr.generators.get_lanes_offset">get_lanes_offset</a></code></li>
<li><code><a title="scenariogeneration.xodr.generators.get_road_by_id" href="#scenariogeneration.xodr.generators.get_road_by_id">get_road_by_id</a></code></li>
<li><code><a title="scenariogeneration.xodr.generators.standard_lane" href="#scenariogeneration.xodr.generators.standard_lane">standard_lane</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>